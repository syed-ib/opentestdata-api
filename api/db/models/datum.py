import json
import hashlib

from enum import Enum
from .. import db
from . import ChildDatum, TestDatum, ItemExistsException
from .base import BaseModel


class DatumType(Enum):
    NULL = 'NULL'
    BOOLEAN = 'BOOL'
    NUMBER = 'NUM'
    STRING = 'STR'
    OBJECT = 'OBJ'


def parse_object_json(obj_str, parent=None):
    obj = json.loads(obj_str)
    data = {}

    if len(obj.values()) != len(set(obj.values())):
        raise Exception('You have a duplicate child object; you can only '
                        'include a child object once per parent object')

    for key in obj.keys():
        if type(obj[key]) != int:
            raise Exception(f'JSON object key {key} was not an integer datum id')

        data[key] = Datum.query.filter_by(id=obj[key]).first()
        if data[key] is None:
            raise Exception(f'Datum id {obj[key]} referenced with object key {key} did not exist')

    if parent is not None and object_is_cyclical(parent, data):
        raise Exception('Cannot create a datum with cyclical child references')

    return data


def object_is_cyclical(parent, data):
    for child_datum in data.values():
        if parent.id == child_datum.id:
            return True
        if child_datum.type == DatumType.OBJECT:
            return object_is_cyclical(parent, child_datum.object_value())
    return False


class Datum(BaseModel):
    __tablename__ = 'data'

    # fields
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    name = db.Column(db.String(length=100), nullable=False)
    type = db.Column(db.Enum(DatumType), default=DatumType.STRING, nullable=False)
    value = db.Column(db.String(length=1024), nullable=True)

    # the purpose of child_ids_hash is to store a hash of a string. This string
    # is just a sorted, comma-separated list of all the ids belonging to the
    # children of this datum (meaning this is of course an object datum). The
    # reason we want to store this information is because we need to check
    # uniqueness of combinations of children, but this is obscenely difficult
    # to do with a SQL query given the use of the intermediary ChildDatum
    # table. It's easier to just keep a hash of the ids here so we can
    # calculate the similar hash for any new datum and check that it doesn't
    # match the hash of an existing datum.
    child_ids_hash = db.Column(db.String(length=128), nullable=True)

    private_fields = []
    # type is not included in public_fields because as an enum we must unwrap
    # it in 'to_obj'
    public_fields = ['name', 'value', 'user_id', 'created_at']

    # relationships
    author = db.relationship('User', back_populates='data', foreign_keys=[user_id])
    children = db.relationship('ChildDatum', back_populates='parent', uselist=True, foreign_keys=lambda: ChildDatum.parent_id)
    included_in = db.relationship('ChildDatum', back_populates='datum', uselist=True, foreign_keys=lambda: ChildDatum.datum_id)
    tests = db.relationship('TestDatum', back_populates='datum', uselist=True, foreign_keys=lambda: TestDatum.datum_id)
    # TODO tags many-many via join table

    def __repr__(self, depth=1):
        if self.type == DatumType.OBJECT:
            children_repr = map(lambda cd: f'{cd.name}: {cd.datum.__repr__(depth + 1)}', self.children)
            space_for_depth = "    " * depth
            children_repr = space_for_depth + ("\n" + space_for_depth).join(children_repr)
            return f"<Datum #{self.id} '{self.name}' (by {self.author.username})\n{children_repr}\n>"
        else:
            return (f"<Datum #{self.id} '{self.name}' "
                    f"[{self.type}: {self.value[:20]}] (by {self.author.username})>")

    def object_value(self):
        if self.type != DatumType.OBJECT:
            return self.value

        value = {}
        for child in self.children:
            value[child.name] = child.datum

        return value

    def to_obj(self, *args, **kwargs):
        obj = super().to_obj(*args, **kwargs)
        obj['type'] = self.type.value
        if self.type == DatumType.OBJECT:
            obj['value'] = {}
            for child in self.children:
                obj['value'][child.name] = child.datum.to_obj(**kwargs)
        return obj

    def update(self, **kwargs):
        if kwargs.get('name') is not None:
            self.name = kwargs['name']
        if kwargs.get('type') is not None:
            self.type = kwargs['type']
        if kwargs.get('value') is not None:
            value = kwargs['value']
            if self.type == DatumType.OBJECT:
                value = parse_object_json(value, parent=self)
            Datum.ensure_uniqueness(value, self.type)

            if self.type != DatumType.OBJECT:
                self.value = value
            else:
                # we have an object type, which means we may need to modify, add,
                # or delete ChildDatum rows corresponding to the child data. The
                # simplest thing is just to delete them all and re-add them all,
                # so do that unless and until it becomes an issue.
                self.remove_children(commit=False)
                self.add_children(value, commit=False)
                self.child_ids_hash = Datum.get_child_ids_hash(value)

            db.session.commit()

    def remove_children(self, commit=True):
        for child in self.children:
            db.session.delete(child)
        if commit:
            db.session.commit()

    def add_children(self, value, commit=True):
        for name, child_datum in value.items():
            child_datum_obj = ChildDatum(parent=self, name=name, datum=child_datum)
            db.session.add(child_datum_obj)

        if commit:
            db.session.commit()

    @staticmethod
    def find(value, type):
        if type == DatumType.OBJECT:
            ids_hash = Datum.get_child_ids_hash(value)
            return Datum.query.filter_by(child_ids_hash=ids_hash).first()

        return Datum.query.filter_by(value=value, type=type).first()

    @staticmethod
    def create(*args, **kwargs):
        value = kwargs['value']
        type = kwargs['type']
        if type == DatumType.OBJECT:
            value = parse_object_json(value)
        Datum.ensure_uniqueness(value, type)
        if type == DatumType.OBJECT:
            kwargs['value'] = None
            kwargs['child_ids_hash'] = Datum.get_child_ids_hash(value)
            datum = Datum(**kwargs)
            db.session.add(datum)
            db.session.flush()
            datum.add_children(value, commit=False)
        else:
            datum = Datum(**kwargs)
            db.session.add(datum)

        db.session.commit()

        return datum

    @staticmethod
    def get_child_ids_hash(obj_value):
        """
        This method creates a (hopefully unique) hash based on the combination
        of child ids. The input to this method is the datum value after it has
        passed through parse_object_json()
        """
        child_ids = list(map(lambda child: child.id, obj_value.values()))
        child_ids.sort()

        ids_str = ",".join(map(lambda i: str(i), child_ids))
        return hashlib.sha1(ids_str.encode('utf-8')).hexdigest()

    @staticmethod
    def ensure_uniqueness(value, type):
        old_datum = Datum.find(value, type)
        if old_datum is not None:
            err = ('The combination of value and type must be unique '
                   'and datum with id %s already contains these values' %
                   old_datum.id)
            raise ItemExistsException(err, item_id=old_datum.id)
