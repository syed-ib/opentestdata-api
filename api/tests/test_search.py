from ..db import db
from secrets import token_urlsafe
from .utils import make_datum, make_object_datum, make_test


def test_basic_search_of_all_objects(client, user):
    query = token_urlsafe(6)

    # find a datum with the query in its name
    d1 = make_datum()
    d1.name = f'{query} world'

    # or in its value
    d2 = make_datum()
    d2.value = f'asdf{query}asdf'

    # or in the name of one of its children
    d3 = make_object_datum()
    d3.children[0].name = f'{query} child datum'

    # and make one datum _not_ to find
    d4 = make_datum()

    # find a test with the query in its name
    t1 = make_test()
    t1.name = f'a basic {query} world test'

    # or in the label of one of its data
    t2 = make_test()
    t2.data[0].label = f'the {query} item'

    # and a test _not_ to find
    t3 = make_test()

    db.session.commit()

    resp = client.post('/search', headers=user.auth_headers, json=dict(
        type='ALL', query=query
    ))

    datum_ids = list(map(lambda d: d['id'], resp['data']))
    test_ids = list(map(lambda t: t['id'], resp['tests']))

    assert set(datum_ids) == set([d1.id, d2.id, d3.id])
    assert set(test_ids) == set([t1.id, t2.id])
    assert d4.id not in datum_ids
    assert t3.id not in test_ids


def test_can_search_for_only_tests(client, user):
    query = token_urlsafe(6)
    d1 = make_datum()
    d1.name = f'{query} world'
    t1 = make_test()
    t1.name = f'a basic {query} world test'
    db.session.commit()
    resp = client.post('/search', headers=user.auth_headers, json=dict(
        type='TESTS', query=query
    ))
    test_ids = list(map(lambda t: t['id'], resp['tests']))

    assert resp['data'] == []
    assert set(test_ids) == set([t1.id])


def test_can_search_for_only_data(client, user):
    query = token_urlsafe(6)
    d1 = make_datum()
    d1.name = f'{query} world'
    t1 = make_test()
    t1.name = f'a basic {query} world test'
    db.session.commit()
    resp = client.post('/search', headers=user.auth_headers, json=dict(
        type='DATA', query=query
    ))
    datum_ids = list(map(lambda d: d['id'], resp['data']))

    assert resp['tests'] == []
    assert set(datum_ids) == set([d1.id])


def test_results_have_no_duplicate_objects(client, user):
    query = token_urlsafe(6)

    # or in the name of one of its children
    d1 = make_object_datum()
    d1.name = f'yet another {query}'
    d1.value = f'a {query} value'
    d1.children[0].name = f'{query} child datum'

    # find a test with the query in its name and a label
    t1 = make_test()
    t1.name = f'a basic {query} world test'
    t1.data[0].label = f'the {query} item'

    db.session.commit()

    resp = client.post('/search', headers=user.auth_headers, json=dict(
        type='ALL', query=query
    ))

    datum_ids = list(map(lambda d: d['id'], resp['data']))
    test_ids = list(map(lambda t: t['id'], resp['tests']))

    assert datum_ids == [d1.id]
    assert test_ids == [t1.id]


def test_search_escapes_sql_match_chars(client, user):
    rand_str = token_urlsafe(6)
    query = f'{rand_str}%foo'
    no_match = f'{rand_str}.foo'
    d1 = make_datum()
    d1.name = f'{query} world'
    d2 = make_datum()
    d2.name = f'{no_match} world'
    db.session.commit()
    resp = client.post('/search', headers=user.auth_headers, json=dict(
        type='DATA', query=query
    ))
    datum_ids = list(map(lambda d: d['id'], resp['data']))

    assert set(datum_ids) == set([d1.id])


def test_search_requires_search_string(client, user):
    query = ''
    resp = client.post('/search', headers=user.auth_headers, json=dict(
        type='ALL', query=query
    ), raw=True)
    assert resp.status_code == 400
    assert 'is too short' in resp.get_json()['detail']

    # single char queries are also not valid
    query = 'a'
    resp = client.post('/search', headers=user.auth_headers, json=dict(
        type='ALL', query=query
    ), raw=True)
    assert resp.status_code == 400
    assert 'is too short' in resp.get_json()['detail']


def test_cant_search_for_nonexisting_types(client, user):
    query = token_urlsafe(6)
    resp = client.post('/search', headers=user.auth_headers, json=dict(
        type='FOO', query=query
    ), raw=True)
    assert resp.status_code == 400
    assert 'is not one of' in resp.get_json()['detail']
