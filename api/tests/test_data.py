import json

from ..db.models import Datum, Action, ActionType
from .utils import make_datum, make_object_datum, make_object_datum_dict


def test_can_create_datum(client, user, datum_dict):
    assert len(user.data) == 0
    resp = client.post('/data', headers=user.auth_headers, json=datum_dict)
    resp_data = dict(
        **datum_dict,
        user_id=user.id
    )
    assert 'created_at' in resp
    assert 'id' in resp

    action = Action.query.filter_by(type=ActionType.CREATE_DATUM, user_id=user.id, obj1_id=resp['id']).first()
    assert action is not None

    del resp['created_at']
    del resp['id']
    assert resp == resp_data
    assert len(user.data) == 1


def test_can_create_object_datum(client, user):
    child_datum_1 = make_datum()
    child_datum_2 = make_datum()
    child_datum_3 = make_datum()
    value = {'foo': child_datum_1.id, 'bar': child_datum_2.id, 'baz': child_datum_3.id}
    datum_dict = dict(name='compound datum', type='OBJ', value=json.dumps(value))
    resp = client.post('/data', headers=user.auth_headers, json=datum_dict)
    datum = Datum.query.filter_by(id=resp['id']).first()
    children = map(lambda cd: cd.datum, datum.children)
    assert set(children) == set([child_datum_1, child_datum_2, child_datum_3])
    assert resp['value']['foo'] == child_datum_1.to_obj(whos_asking=user)
    assert resp['value']['bar'] == child_datum_2.to_obj(whos_asking=user)
    assert resp['value']['baz'] == child_datum_3.to_obj(whos_asking=user)


def test_create_datum_requires_login(client, datum_dict):
    resp = client.post('/data', json=datum_dict, raw=True)
    assert resp.status_code == 401
    assert 'authorization' in resp.get_json()['detail']


def test_cant_create_datum_without_required_fields(client, user, datum_dict):
    req_fields = ['name', 'type', 'value']
    for req_field in req_fields:
        bad_input = dict(**datum_dict)
        del bad_input[req_field]
        resp = client.post('/data', headers=user.auth_headers, json=bad_input, raw=True)
        assert resp.status_code == 400
        assert req_field in resp.get_json()['detail']
    assert user.data == []


def test_cant_create_datum_with_extra_fields(client, user, datum_dict):
    bad_input = dict(**datum_dict)
    bad_input['extra'] = 'foo'
    resp = client.post('/data', headers=user.auth_headers, json=bad_input, raw=True)
    assert resp.status_code == 400
    assert 'extra' in resp.get_json()['detail']


def test_cant_create_datum_with_bad_input(client, user, datum_dict):
    bad_input = dict(**datum_dict)
    bad_input['type'] = 'STRRR'
    resp = client.post('/data', headers=user.auth_headers, json=bad_input, raw=True)
    assert resp.status_code == 400
    assert 'STR' in resp.get_json()['detail']


def test_cant_create_datum_that_already_exists(client, user, datum_dict):
    assert len(user.data) == 0
    datum = client.post('/data', headers=user.auth_headers, json=datum_dict)
    assert len(user.data) == 1
    new_dict = dict(**datum_dict)
    new_dict['name'] = 'a new name'
    resp = client.post('/data', headers=user.auth_headers, json=new_dict, raw=True)
    assert resp.status_code == 500
    resp = resp.get_json()
    assert 'already' in resp['error']
    assert resp['datum_id'] == datum['id']
    assert len(user.data) == 1


def test_cant_create_object_datum_that_already_exists(client, user):
    # make the first copy
    child_datum_1 = make_datum()
    child_datum_2 = make_datum()
    child_datum_3 = make_datum()
    value = {'foo': child_datum_1.id, 'bar': child_datum_2.id, 'baz': child_datum_3.id}
    datum_dict = dict(name='compound datum', type='OBJ', value=json.dumps(value))
    resp1 = client.post('/data', headers=user.auth_headers, json=datum_dict)

    # make the second copy, with different names but same child data
    value = {'oof': child_datum_1.id, 'rab': child_datum_2.id, 'zab': child_datum_3.id}
    datum_dict = dict(name='mutad dnuopmoc', type='OBJ', value=json.dumps(value))
    resp2 = client.post('/data', headers=user.auth_headers, json=datum_dict, raw=True)
    assert resp2.status_code == 500
    assert resp2.get_json()['datum_id'] == resp1['id']


def test_cant_create_object_datum_with_duplicate_children(client, user):
    child_datum_1 = make_datum()
    child_datum_2 = make_datum()
    value = {'foo': child_datum_1.id, 'bar': child_datum_2.id, 'baz': child_datum_2.id}
    datum_dict = dict(name='compound datum', type='OBJ', value=json.dumps(value))
    resp = client.post('/data', headers=user.auth_headers, json=datum_dict, raw=True)
    assert resp.status_code == 500
    assert 'duplicate' in resp.get_json()['error']


def test_can_update_datum(client, datum):
    new_datum_dict = dict(name='new datum', type='NUM', value='500')
    updated_datum = client.post(f'/data/{datum.id}', headers=datum.author.auth_headers,
                                json=new_datum_dict)
    new_datum_dict['id'] = datum.id
    new_datum_dict['user_id'] = datum.author.id
    del updated_datum['created_at']
    assert updated_datum == new_datum_dict

    action = Action.query.filter_by(type=ActionType.UPDATE_DATUM, user_id=datum.author.id, obj1_id=datum.id).first()
    assert action is not None


def test_cant_update_datum_thats_not_yours(client, datum, user, datum_dict):
    assert datum.name != datum_dict['name']
    resp = client.post(f'/data/{datum.id}', headers=user.auth_headers,
                       json=datum_dict, raw=True)
    assert resp.status_code == 401
    resp = resp.get_json()
    assert 'name' not in resp


def test_cant_update_datum_with_bad_input(client, datum):
    new_datum_dict = dict(name='new datum', type='STRRR', value='500')
    resp = client.post(f'/data/{datum.id}', headers=datum.author.auth_headers, json=new_datum_dict, raw=True)
    assert resp.status_code == 400
    assert 'STR' in resp.get_json()['detail']


def test_can_update_datum_thats_not_yours_if_admin(client, datum, admin_user, datum_dict):
    new_datum_dict = dict(name='new datum from admin', type='NUM', value='501')
    updated_datum = client.post(f'/data/{datum.id}', headers=admin_user.auth_headers,
                                json=new_datum_dict)
    new_datum_dict['id'] = datum.id
    new_datum_dict['user_id'] = datum.author.id
    del updated_datum['created_at']
    assert updated_datum == new_datum_dict


def test_can_update_object_datum(client, user, object_datum_dict):
    object_datum = make_object_datum(author=user)
    updated_datum = client.post(f'/data/{object_datum.id}', headers=user.auth_headers,
                                json=object_datum_dict)
    updated_datum['value'].keys() == object_datum_dict.keys()
    updated_datum['value'].keys() == object_datum.object_value().keys()


def _update_obj_datum_dict(odd, new_child_id):
    odd['value'] = json.loads(odd['value'])
    first_key = list(odd['value'].keys())[0]
    odd['value'][first_key] = new_child_id
    odd['value'] = json.dumps(odd['value'])


def test_cant_update_datum_with_cyclical_children(client, user, object_datum_dict):
    object_datum = make_object_datum(author=user, object_datum_dict=object_datum_dict)

    # first test a 1-level cycle by setting one of the children in our update
    # dict to the same id as the updating object datum
    _update_obj_datum_dict(object_datum_dict, object_datum.id)
    resp = client.post(f'/data/{object_datum.id}', headers=user.auth_headers,
                       json=object_datum_dict, raw=True)
    assert resp.status_code == 500
    assert 'cyclical' in resp.get_json()['error']

    # now test a multi-level cycle by creating a new object datum which
    # makes a child out of the first. then try to update the first with the new
    # datum as its own child
    child_dict = make_object_datum_dict()
    _update_obj_datum_dict(child_dict, object_datum.id)
    child_datum = make_object_datum(author=user, object_datum_dict=child_dict)
    _update_obj_datum_dict(object_datum_dict, child_datum.id)
    resp = client.post(f'/data/{object_datum.id}', headers=user.auth_headers,
                       json=object_datum_dict, raw=True)
    assert resp.status_code == 500
    assert 'cyclical' in resp.get_json()['error']


def test_cant_update_datum_with_cyclical_parent(client, user, object_datum_dict):
    object_datum = make_object_datum(author=user, object_datum_dict=object_datum_dict)
    parent_dict = make_object_datum_dict()
    _update_obj_datum_dict(parent_dict, object_datum.id)
    parent_datum = make_object_datum(author=user, object_datum_dict=parent_dict)
    _update_obj_datum_dict(object_datum_dict, parent_datum.id)

    resp = client.post(f'/data/{object_datum.id}', headers=user.auth_headers,
                       json=object_datum_dict, raw=True)
    assert resp.status_code == 500
    assert 'cyclical' in resp.get_json()['error']


def test_can_get_datum_details(client, datum, user):
    resp = client.get(f'/data/{datum.id}', headers=user.auth_headers)
    expected = datum.to_obj(whos_asking=user)
    del expected['created_at']
    del resp['created_at']
    assert resp == expected

    action = Action.query.filter_by(type=ActionType.LIST_DATUM, user_id=user.id, obj1_id=datum.id).first()
    assert action is not None


def test_cant_get_datum_that_doesnt_exist(client, user):
    resp = client.get(f'/data/999999', headers=user.auth_headers, raw=True)
    assert resp.status_code == 404
